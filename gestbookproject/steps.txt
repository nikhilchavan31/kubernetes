Simple Kubernetes Project: Deploying a Guestbook Application
I'll provide you with a complete, beginner-friendly Kubernetes (K8s) project example. This is a classic "Guestbook" application that demonstrates key K8s concepts: Deployments for managing replicas, Services for networking, and ConfigMaps for configuration. It's based on the official Kubernetes examples, which include all necessary YAML files for deployment.
This project deploys a simple web app where users can leave messages (frontend) and store them in a Redis backend. You can run it on a local cluster like Minikube or a cloud-based one like GKE/AKS/EKS.
Prerequisites

Install kubectl (K8s CLI).
Install Minikube for a local cluster (optional but recommended for testing).
Docker (for building if needed, but we'll use pre-built images).
Start Minikube: minikube start.

Project Structure
Create a new directory for the project, e.g., k8s-guestbook, and add the files below inside it. All files are YAML manifests.
textk8s-guestbook/
├── README.md                 # Project instructions
├── frontend-deployment.yaml  # Deployment for the web frontend
├── frontend-service.yaml     # Service to expose the frontend
├── redis-leader-deployment.yaml # Deployment for Redis leader (primary)
├── redis-leader-service.yaml # Service for Redis leader
├── redis-follower-deployment.yaml # Deployment for Redis followers (replicas)
├── redis-follower-service.yaml # Service for Redis followers
└── redis-configmap.yaml      # ConfigMap for Redis configuration
1. README.md
text# Kubernetes Guestbook Project

A simple multi-tier web application using Kubernetes.

## Deploy
1. Start your cluster (e.g., minikube start).
2. Apply all YAMLs: kubectl apply -f .
3. Access the app: minikube service frontend-service (or use port-forward: kubectl port-forward svc/frontend-service 8080:80).

## View
- Pods: kubectl get pods
- Logs: kubectl logs <pod-name>
- Dashboard: minikube dashboard

## Cleanup
kubectl delete -f .
2. redis-configmap.yaml
yamlapiVersion: v1
kind: ConfigMap
metadata:
  name: redis-config
data:
  update-node.conf: |
    # Redis config for leader
    port 6379
    cluster-enabled yes
    cluster-require-full-coverage no
  slave-node.conf: |
    # Redis config for followers
    port 6379
    cluster-enabled yes
    cluster-require-full-coverage no
    cluster-node-timeout 5000
    appendonly yes
3. redis-leader-deployment.yaml
yamlapiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-leader
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
      role: leader
      tier: backend
  template:
    metadata:
      labels:
        app: redis
        role: leader
        tier: backend
    spec:
      containers:
      - name: redis-leader
        image: docker.io/redis:7.0.5-alpine
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
        ports:
        - containerPort: 6379
        volumeMounts:
        - name: redis-config
          mountPath: /usr/local/etc/redis/redis.conf
          subPath: update-node.conf
        command: ["/bin/sh"]
        args: ["-c", "redis-server /usr/local/etc/redis/redis.conf"]
      volumes:
      - name: redis-config
        configMap:
          name: redis-config
4. redis-leader-service.yaml
yamlapiVersion: v1
kind: Service
metadata:
  name: redis-leader
  labels:
    app: redis
    role: leader
    tier: backend
spec:
  ports:
  - port: 6379
    targetPort: 6379
  selector:
    app: redis
    role: leader
    tier: backend
5. redis-follower-deployment.yaml
yamlapiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-follower
spec:
  replicas: 2
  selector:
    matchLabels:
      app: redis
      role: follower
      tier: backend
  template:
    metadata:
      labels:
        app: redis
        role: follower
        tier: backend
    spec:
      containers:
      - name: redis-follower
        image: docker.io/redis:7.0.5-alpine
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
        ports:
        - containerPort: 6379
        volumeMounts:
        - name: redis-config
          mountPath: /usr/local/etc/redis/redis.conf
          subPath: slave-node.conf
        command: ["/bin/sh"]
        args: ["-c", "redis-server /usr/local/etc/redis/redis.conf"]
      volumes:
      - name: redis-config
        configMap:
          name: redis-config
6. redis-follower-service.yaml
yamlapiVersion: v1
kind: Service
metadata:
  name: redis-follower
  labels:
    app: redis
    role: follower
    tier: backend
spec:
  ports:
  - port: 6379
    targetPort: 6379
  selector:
    app: redis
    role: follower
    tier: backend
7. frontend-deployment.yaml
yamlapiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: guestbook
      tier: frontend
  template:
    metadata:
      labels:
        app: guestbook
        tier: frontend
    spec:
      containers:
      - name: php-redis
        image: docker.io/kubernetes-samples/guestbook:v1  # Pre-built image
        env:
        - name: GET_HOSTS_FROM
          value: "dns"
        ports:
        - containerPort: 80
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
        volumeMounts:
        - mountPath: /etc/nginx
          name: nginx-config
          readOnly: true
      volumes:
      - name: nginx-config
        configMap:
          name: nginx-config  # Assumes a basic nginx ConfigMap; create if needed
8. frontend-service.yaml
yamlapiVersion: v1
kind: Service
metadata:
  name: frontend-service
  labels:
    app: guestbook
    tier: frontend
spec:
  type: NodePort  # Use LoadBalancer in cloud
  ports:
  - port: 80
    targetPort: 80
  selector:
    app: guestbook
    tier: frontend
Deployment Instructions

Navigate to the project directory: cd k8s-guestbook.
Apply all manifests: kubectl apply -f . (in order: ConfigMap first, then Deployments/Services).
Verify:

kubectl get deployments (should show 3 deployments ready).
kubectl get services (frontend-service gets a NodePort).


Access the app:

Local (Minikube): minikube service frontend-service.
Port-forward: kubectl port-forward service/frontend-service 8080:80 then open http://localhost:8080.


Leave a message in the guestbook—it should store in Redis!

Cleanup
kubectl delete -f .
This project covers all necessary files for a basic multi-container app. For more advanced features (e.g., Ingress, HPA), check the official Kubernetes examples repo. If you need expansions like Helm charts or CI/CD, let me know
